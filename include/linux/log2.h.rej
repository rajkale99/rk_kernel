--- include/linux/log2.h
+++ include/linux/log2.h
@@ -39,23 +40,19 @@  int __ilog2_u64(u64 n)
 }
 #endif
 
-/**
- * is_power_of_2() - check if a value is a power of two
- * @n: the value to check
- *
- * Determine whether some value is a power of two, where zero is
+/*
+ *  Determine whether some value is a power of two, where zero is
  * *not* considered a power of two.
- * Return: true if @n is a power of 2, otherwise false.
  */
+
 static inline __attribute__((const))
 bool is_power_of_2(unsigned long n)
 {
 	return (n != 0 && ((n & (n - 1)) == 0));
 }
 
-/**
- * __roundup_pow_of_two() - round up to nearest power of two
- * @n: value to round up
+/*
+ * round up to nearest power of two
  */
 static inline __attribute__((const))
 unsigned long __roundup_pow_of_two(unsigned long n)
@@ -63,9 +60,8 @@  unsigned long __roundup_pow_of_two(unsigned long n)
 	return 1UL << fls_long(n - 1);
 }
 
-/**
- * __rounddown_pow_of_two() - round down to nearest power of two
- * @n: value to round down
+/*
+ * round down to nearest power of two
  */
 static inline __attribute__((const))
 unsigned long __rounddown_pow_of_two(unsigned long n)
@@ -74,19 +70,19 @@  unsigned long __rounddown_pow_of_two(unsigned long n)
 }
 
 /**
- * ilog2 - log base 2 of 32-bit or a 64-bit unsigned value
- * @n: parameter
+ * ilog2 - log of base 2 of 32-bit or a 64-bit unsigned value
+ * @n - parameter
  *
  * constant-capable log of base 2 calculation
  * - this can be used to initialise global variables from constant data, hence
- * the massive ternary operator construction
+ *   the massive ternary operator construction
  *
  * selects the appropriately-sized optimised version depending on sizeof(n)
  */
 #define ilog2(n)				\
 (						\
 	__builtin_constant_p(n) ? (		\
-		(n) < 2 ? 0 :			\
+		(n) < 1 ? ____ilog2_NaN() :	\
 		(n) & (1ULL << 63) ? 63 :	\
 		(n) & (1ULL << 62) ? 62 :	\
 		(n) & (1ULL << 61) ? 61 :	\
@@ -149,7 +145,10 @@  unsigned long __rounddown_pow_of_two(unsigned long n)
 		(n) & (1ULL <<  4) ?  4 :	\
 		(n) & (1ULL <<  3) ?  3 :	\
 		(n) & (1ULL <<  2) ?  2 :	\
-		1) :				\
+		(n) & (1ULL <<  1) ?  1 :	\
+		(n) & (1ULL <<  0) ?  0 :	\
+		____ilog2_NaN()			\
+				   ) :		\
 	(sizeof(n) <= 4) ?			\
 	__ilog2_u32(n) :			\
 	__ilog2_u64(n)				\
@@ -157,7 +156,7 @@  unsigned long __rounddown_pow_of_two(unsigned long n)
 
 /**
  * roundup_pow_of_two - round the given value up to nearest power of two
- * @n: parameter
+ * @n - parameter
  *
  * round the given value up to the nearest power of two
  * - the result is undefined when n == 0
@@ -174,7 +173,7 @@  unsigned long __rounddown_pow_of_two(unsigned long n)
 
 /**
  * rounddown_pow_of_two - round the given value down to nearest power of two
- * @n: parameter
+ * @n - parameter
  *
  * round the given value down to the nearest power of two
  * - the result is undefined when n == 0
@@ -187,12 +186,6 @@  unsigned long __rounddown_pow_of_two(unsigned long n)
 	__rounddown_pow_of_two(n)		\
  )
 
-static inline __attribute_const__
-int __order_base_2(unsigned long n)
-{
-	return n > 1 ? ilog2(n - 1) + 1 : 0;
-}
-
 /**
  * order_base_2 - calculate the (rounded up) base 2 order of the argument
  * @n: parameter
@@ -206,11 +199,7 @@  unsigned long __rounddown_pow_of_two(unsigned long n)
  *  ob2(5) = 3
  *  ... and so on.
  */
-#define order_base_2(n)				\
-(						\
-	__builtin_constant_p(n) ? (		\
-		((n) == 0 || (n) == 1) ? 0 :	\
-		ilog2((n) - 1) + 1) :		\
-	__order_base_2(n)			\
-)
+
+#define order_base_2(n) ilog2(roundup_pow_of_two(n))
+
 
